#include "stdafx.h"  
#include <stdio.h>  
#include <winsock2.h>  
#include <windows.h>
#include <cstring>
#include <iostream>

//#include <boost/thread/thread.hpp>
#include <atlbase.h>  
extern "C" {
#include <libavformat/avformat.h>
#include <libavutil/dict.h>
#include "libavcodec/avcodec.h"
}
#pragma comment(lib,"avformat.lib")
#pragma comment(lib,"avcodec.lib")
#pragma comment(lib,"avutil.lib")
#pragma comment(lib,"swscale.lib")
#pragma comment(lib,"swresample.lib")
#pragma comment(lib, "ws2_32.lib")   
#define ASSERT(X) if(!(X)){printf("####[%s:%d]assert failed:%s\n", __FUNCTION__, __LINE__, #X);}
#define _READ_BUF_SIZE (4<<10)
//广播包
BYTE buffer[] = { 0xf1, 0x30, 0x00, 0x00 };
//请求视频
BYTE buffer2[] = {
	0xf1, 0xd0, 0x00, 0xbe, 0xd1, 0x00, 0x00, 0x00,
	0x01, 0x0a, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00,
	0x47, 0x45, 0x54, 0x20, 0x2f, 0x6c, 0x69, 0x76,
	0x65, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x2e,
	0x63, 0x67, 0x69, 0x3f, 0x73, 0x74, 0x72, 0x65,
	0x61, 0x6d, 0x69, 0x64, 0x3d, 0x31, 0x30, 0x26,
	0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x65, 0x61,
	0x6d, 0x3d, 0x30, 0x26, 0x6c, 0x6f, 0x67, 0x69,
	0x6e, 0x75, 0x73, 0x65, 0x3d, 0x61, 0x64, 0x6d,
	0x69, 0x6e, 0x26, 0x6c, 0x6f, 0x67, 0x69, 0x6e,
	0x70, 0x61, 0x73, 0x3d, 0x38, 0x38, 0x38, 0x38,
	0x38, 0x38, 0x26, 0x75, 0x73, 0x65, 0x72, 0x3d,
	0x61, 0x64, 0x6d, 0x69, 0x6e, 0x26, 0x70, 0x77,
	0x64, 0x3d, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38,
	0x26, 0x01, 0x0a, 0x00, 0x00, 0x49, 0x00, 0x00,
	0x00, 0x47, 0x45, 0x54, 0x20, 0x2f, 0x63, 0x68,
	0x65, 0x63, 0x6b, 0x5f, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x63, 0x67, 0x69, 0x3f, 0x6c, 0x6f, 0x67,
	0x69, 0x6e, 0x75, 0x73, 0x65, 0x3d, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x26, 0x6c, 0x6f, 0x67, 0x69,
	0x6e, 0x70, 0x61, 0x73, 0x3d, 0x38, 0x38, 0x38,
	0x38, 0x38, 0x38, 0x26, 0x75, 0x73, 0x65, 0x72,
	0x3d, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x26, 0x70,
	0x77, 0x64, 0x3d, 0x38, 0x38, 0x38, 0x38, 0x38,
	0x38, 0x26 };
//
BYTE buffer3[] = {
	0xf1, 0x41, 0x00, 0x14, 0x56, 0x53, 0x54, 0x42,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x18, 0x72,
	0x52, 0x4d, 0x53, 0x52, 0x50, 0x00, 0x00, 0x00 };
//左转
BYTE buffer4[] = {
	0xf1,0xd0,0x00,0x6e,0xd1,0x00,0x00,0x01,0x01,
	0x0a,0x00,0x00,0x62,0x00,0x00,0x00,0x47,0x45,
	0x54,0x20,0x2f,0x64,0x65,0x63,0x6f,0x64,0x65,
	0x72,0x5f,0x63,0x6f,0x6e,0x74,0x72,0x6f,0x6c,
	0x2e,0x63,0x67,0x69,0x3f,0x63,0x6f,0x6d,0x6d,
	0x61,0x6e,0x64,0x3d,0x37,0x26,0x6f,0x6e,0x65,
	0x73,0x74,0x65,0x70,0x3d,0x30,0x26,0x6c,0x6f,
	0x67,0x69,0x6e,0x75,0x73,0x65,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x6c,0x6f,0x67,0x69,0x6e,
	0x70,0x61,0x73,0x3d,0x35,0x32,0x31,0x35,0x32,
	0x31,0x26,0x75,0x73,0x65,0x72,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x70,0x77,0x64,0x3d,0x35,
	0x32,0x31,0x35,0x32,0x31,0x26 };
BYTE buffer41[] = {
	0xf1,0xd0,0x00,0x6e,0xd1,0x00,0x00,0x04,0x01,
	0x0a,0x00,0x00,0x62,0x00,0x00,0x00,0x47,0x45,
	0x54,0x20,0x2f,0x64,0x65,0x63,0x6f,0x64,0x65,
	0x72,0x5f,0x63,0x6f,0x6e,0x74,0x72,0x6f,0x6c,
	0x2e,0x63,0x67,0x69,0x3f,0x63,0x6f,0x6d,0x6d,
	0x61,0x6e,0x64,0x3d,0x36,0x26,0x6f,0x6e,0x65,
	0x73,0x74,0x65,0x70,0x3d,0x30,0x26,0x6c,0x6f,
	0x67,0x69,0x6e,0x75,0x73,0x65,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x6c,0x6f,0x67,0x69,0x6e,
	0x70,0x61,0x73,0x3d,0x35,0x32,0x31,0x35,0x32,
	0x31,0x26,0x75,0x73,0x65,0x72,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x70,0x77,0x64,0x3d,0x35,
	0x32,0x31,0x35,0x32,0x31,0x26 };

//拍照
BYTE buffer7[] = {
	0xf1,0xd0,0x00,0x59,0xd1,0x00,0x00,0x01,0x01,
	0x0a,0x00,0x00,0x49,0x00,0x00,0x00,0x47,0x45,
	0x54,0x20,0x2f,0x73,0x6e,0x61,0x70,0x73,0x68,
	0x6f,0x74,0x2e,0x63,0x67,0x69,0x3f,0x6c,0x6f,
	0x67,0x69,0x6e,0x75,0x73,0x65,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x6c,0x6f,0x67,0x69,0x6e,
	0x70,0x61,0x73,0x3d,0x35,0x32,0x31,0x35,0x32,
	0x31,0x26,0x75,0x73,0x65,0x72,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x70,0x77,0x64,0x3d,0x35,
	0x32,0x31,0x35,0x32,0x31,0x26,0x72,0x65,0x73,
	0x3d,0x31,0x26 };
BYTE buffer5[] = {
	0xf1, 0xd1, 0x00, 0x06,0xd1,0x00,0x00,0x01,0x00,0x50 };
BYTE buffer8[] = {
	0xf1, 0xe1, 0x00, 0x00 };
BYTE buffer9[] = {
	0xf1, 0xe0, 0x00, 0x00 };
//get_status.cgi
BYTE buffer6[] = {
	0xf1,0xd0,0x00,0xad,0xd1,0x00,0x00,0x01,0x01,
	0x0a,0x00,0x00,0x49,0x00,0x00,0x00,0x47,0x45,
	0x54,0x20,0x2f,0x67,0x65,0x74,0x5f,0x73,0x74,
	0x61,0x74,0x75,0x73,0x2e,0x63,0x67,0x69,0x3f,
	0x6c,0x6f,0x67,0x69,0x6e,0x75,0x73,0x65,0x3d,
	0x61,0x64,0x6d,0x69,0x6e,0x26,0x6c,0x6f,0x67,
	0x69,0x6e,0x70,0x61,0x73,0x3d,0x38,0x38,0x38,
	0x38,0x38,0x38,0x26,0x75,0x73,0x65,0x72,0x3d,
	0x61,0x64,0x6d,0x69,0x6e,0x26,0x70,0x77,0x64,
	0x3d,0x38,0x38,0x38,0x38,0x38,0x38,0x26,0x01,
	0x0a,0x00,0x00,0x50,0x00,0x00,0x00,0x47,0x45,
	0x54,0x20,0x2f,0x67,0x65,0x74,0x5f,0x66,0x61,
	0x63,0x74,0x6f,0x72,0x79,0x5f,0x70,0x61,0x72,
	0x61,0x6d,0x2e,0x63,0x67,0x69,0x3f,0x6c,0x6f,
	0x67,0x69,0x6e,0x75,0x73,0x65,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x6c,0x6f,0x67,0x69,0x6e,
	0x70,0x61,0x73,0x3d,0x38,0x38,0x38,0x38,0x38,
	0x38,0x26,0x75,0x73,0x65,0x72,0x3d,0x61,0x64,
	0x6d,0x69,0x6e,0x26,0x70,0x77,0x64,0x3d,0x38,
	0x38,0x38,0x38,0x38,0x38,0x26 };
//521521密码的请求视频
BYTE buffer1[] = {
	0xf1, 0xd0, 0x00, 0xbe, 0xd1, 0x00, 0x00, 0x00,
	0x01, 0x0a, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00,
	0x47, 0x45, 0x54, 0x20, 0x2f, 0x6c, 0x69, 0x76,
	0x65, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x2e,
	0x63, 0x67, 0x69, 0x3f, 0x73, 0x74, 0x72, 0x65,
	0x61, 0x6d, 0x69, 0x64, 0x3d, 0x31, 0x30, 0x26,
	0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x65, 0x61,
	0x6d, 0x3d, 0x30, 0x26, 0x6c, 0x6f, 0x67, 0x69,
	0x6e, 0x75, 0x73, 0x65, 0x3d, 0x61, 0x64, 0x6d,
	0x69, 0x6e, 0x26, 0x6c, 0x6f, 0x67, 0x69, 0x6e,
	0x70, 0x61, 0x73, 0x3d, 0x35, 0x32, 0x31, 0x35,
	0x32, 0x31, 0x26, 0x75, 0x73, 0x65, 0x72, 0x3d,
	0x61, 0x64, 0x6d, 0x69, 0x6e, 0x26, 0x70, 0x77,
	0x64, 0x3d, 0x35, 0x32, 0x31, 0x35, 0x32, 0x31,
	0x26, 0x01, 0x0a, 0x00, 0x00, 0x49, 0x00, 0x00,
	0x00, 0x47, 0x45, 0x54, 0x20, 0x2f, 0x63, 0x68,
	0x65, 0x63, 0x6b, 0x5f, 0x75, 0x73, 0x65, 0x72,
	0x2e, 0x63, 0x67, 0x69, 0x3f, 0x6c, 0x6f, 0x67,
	0x69, 0x6e, 0x75, 0x73, 0x65, 0x3d, 0x61, 0x64,
	0x6d, 0x69, 0x6e, 0x26, 0x6c, 0x6f, 0x67, 0x69,
	0x6e, 0x70, 0x61, 0x73, 0x3d, 0x35, 0x32, 0x31,
	0x35, 0x32, 0x31, 0x26, 0x75, 0x73, 0x65, 0x72,
	0x3d, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0x26, 0x70,
	0x77, 0x64, 0x3d, 0x35, 0x32, 0x31, 0x35, 0x32,
	0x31, 0x26
};
#include <stdio.h>  
#include <string.h>  
int n = 0;
int getdiff(char ch);
void change()
{
	FILE *rfp, *wfp;
	char msg[256];

	rfp = fopen("C:/Users/36970/Documents/software/ipcamera/v264.txt", "r");
	wfp = fopen("C:/Users/36970/Documents/software/ipcamera/v264.264", "w+b");

	if (rfp == NULL || wfp == NULL)
		return;

	int i, num;
	while (!feof(rfp))
	{
		fgets(msg, 4, rfp);
		i = 0;
		while (msg[i] != 0x0a && i<1)//0x0a代表换行符，应为该文本打印出来是16进制的格式所以读取的ASCII的值是16进制的，而16进制中0x0a正好代表换行符  
		{ // if(msg[i]==0x20){i++;}
			num = 0;
			num = getdiff(msg[i]) * 16;//*16，  
			num += getdiff(msg[i + 1]);//加上后一位  

			i += 3;//跳过空格  
			fwrite(&num, 1, 1, wfp);//fwrite（指针存放输出数据的首地址，数据块的字节数，读取数据块的个数，文本指针）？不确定打印的结果1个字节1个字节打印所以用1  
		}
	}
	fclose(wfp);
	fclose(rfp);
}
//将字符转换成整数  
int getdiff(char ch)
{
	int diff = 0;
	if (ch >= '0' && ch <= '9')
		diff = ch - '0';
	else if (ch >= 'A' && ch <= 'F')
		diff = ch - 'A' + 10;//换位11到15的数字  
	else printf("不是0-15的数字");
	return diff;

}
void recvw(FILE *FSPOINTER) {
	int lent = 0;
	int i = 8;
	char recvbuf[1200];

	WORD socketVersion = MAKEWORD(2, 2);
	WSADATA wsaData;
	if (WSAStartup(socketVersion, &wsaData) != 0)
	{
		return;
	}
	SOCKET sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

	SOCKADDR_IN addrSrv;
	// addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY); 
	addrSrv.sin_family = AF_INET;
	addrSrv.sin_port = htons(32108);
	addrSrv.sin_addr.S_un.S_addr = inet_addr("192.168.199.255");
	//INADDR_BROADCAST inet_addr("192.168.1.255");  
	int len = sizeof(addrSrv);

	//char * sendData = "来自客户端的数据包.\n";  
	//send( sclient,(LPCSTR)buffer, sizeof(buffer), 0); 
	//发送寻找局域网内摄像头的buffer数据包
	printf("发送广播包\n");
	sendto(sclient, (LPCSTR)buffer, sizeof(buffer), 0, (sockaddr *)&addrSrv, len);
	SOCKADDR_IN addrClient;
	//接收客户端回应

	recvfrom(sclient, recvbuf, sizeof(recvbuf), 0, (SOCKADDR *)&addrClient, &len);

	printf("接收到客户端回应\n");

	for (int q = 0; q<10; q++) { printf("%x\n", (unsigned char)recvbuf[q]); }
	closesocket(sclient);
	sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);
	addrSrv.sin_family = AF_INET;
	addrSrv.sin_port = htons(32108);
	bind(sclient, (SOCKADDR*)&addrSrv, sizeof(SOCKADDR));
	len = sizeof(SOCKADDR);
	//recvfrom(sclient, recvbuf, sizeof(recvbuf), 0, (SOCKADDR *)&addrClient, &len);



	Sleep(200);
	//发送buffer3（UID）信息，类似于登录
	sendto(sclient, (LPCSTR)buffer3, sizeof(buffer3), 0, (sockaddr *)&addrClient, len); //回应
	Sleep(2000);

	sendto(sclient, (LPCSTR)buffer1, sizeof(buffer1), 0, (sockaddr *)&addrClient, len); //请求视频

	BYTE bufferack[] = {
		0xf1, 0xd1, 0x00, 0x08,0xd1,0x01,0x00,
		0x02,
		0x00,0x00,0x00,0x01,
	};
	BYTE bufferackff[] = {
		0xf1, 0xd1, 0x00, 0x06,0xd1,0x01,0x00,
		0x01,
		0x00,0xff,
	};

	//loop:
	while (1) {
		if (n == 1) {
			break;
		}
		//接受
		recvfrom(sclient, recvbuf, sizeof(recvbuf), 0, (SOCKADDR *)&addrClient, &len);
		//判断是否是视频帧，获取帧号，判断是否是最后一帧，不是就继续接受
		
		if ((unsigned char)recvbuf[4] == 0xd1 && (unsigned char)recvbuf[5] == 0x01) {
			if ((unsigned char)recvbuf[8] == 0x55 && (unsigned char)recvbuf[9] == 0xaa) {
				//i是读取数据的起始点
				i = 41;


			}
			else {
				i = 8;
				//fopen_s(&FSPOINTER, "C:/Users/36970/Documents/software/ipcamera/v264.txt", "a+");
			}

			if ((unsigned char)recvbuf[7] % 2 == 0x01 && (unsigned char)recvbuf[7] != 0xFF)
			{
				int p = 11;
				unsigned char var = recvbuf[7];
				for (char q = 0x00; q < 0x02; q++)
				{
					bufferack[p] = var;
					var = var - 0x01;
					p = p - 2;
				}
				bufferack[8] = recvbuf[6];
				bufferack[10] = recvbuf[6];
				sendto(sclient, (LPCSTR)bufferack, sizeof(bufferack), 0, (sockaddr *)&addrClient, len); //回应
																										//q++;
			}
			else if ((unsigned char)recvbuf[7] == 0xFF) {
				bufferackff[8] = recvbuf[6];
				bufferackff[9] = recvbuf[7];
				sendto(sclient, (LPCSTR)bufferackff, sizeof(bufferackff), 0, (sockaddr *)&addrClient, len); //回应
				bufferackff[9] = 0xfe;
				sendto(sclient, (LPCSTR)bufferackff, sizeof(bufferackff), 0, (sockaddr *)&addrClient, len); //回应
			}



			while (i<(((unsigned char)recvbuf[2] - 0x00) * 16 * 16 + ((unsigned char)recvbuf[3] - 0x00)) + 4) {
				//1032是最大数据长度 

				fprintf(FSPOINTER, "%02hhX ", (unsigned char)recvbuf[i]);
				i++;
			}

			

		}



		//记录视频帧数量，发送确认帧
		//视频帧头f1 d0 04 04 d1 01 00 a9（视频帧的序号）
		//确认帧格式：f1 d1 00 16（后面帧长度） d1 01 00 09（收到的帧的数量） 00 a6 00 a7 00 a8 00 a9 00 aa 00 ab 00 ac 00 ad 00 ae（帧编号）

	}
	fclose(FSPOINTER);
	closesocket(sclient);
	WSACleanup();
}
//#pragma warning(disable:4996)
int main(int argc, char* argv[])
{

	FILE *FSPOINTER;
	fopen_s(&FSPOINTER, "C:/Users/36970/Documents/software/ipcamera/v264.txt", "a+");
	
	recvw(FSPOINTER);
	change();
	

	return 0;
}